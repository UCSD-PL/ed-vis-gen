/// <reference path="../../../typings/browser/ambient/underscore/underscore.d.ts" />
/// <reference path="util.ts"/>
/// <reference path="DFExpr.ts"/>

module Eddiflow {
  export class DFNetwork {
    // internal map from variable names to expressions
    private network: Map<expr>;
    // cache of variable values, mapping from name to value.
    private cachedVals: Map<number>;
    // bookkeeping for unevaluated/evaluated variables. we ensure variables
    // are only ever evaluated *once* per evaluation cycle. if a variable
    // maps to true in here, it is safe to pull its value from cachedVals.
    private forcedVals: Map<boolean>;

    // map from variables to things that depend on them (i.e., forward dependencies).
    // so, if i have x <- y + 1 in the network, this map should encode
    // y -> x.
    private affectedBy: Map<string[]>;

    // parser, currently generated by jison and passed into the constructor;
    private parser: any;

    constructor(parserObj: any){
      this.network = {};
      this.cachedVals = {};
      this.forcedVals = {};
      this.affectedBy = {};
      this.parser = parserObj;
    }
    // convert json-y objects to DF expressions
    // assumes structure is:
    // {tag: "binop" | "unop" | "app" | "number" | "var",
    //  body: <depends on tag>
    // }


    // public parse api: if given a string, invoke the parser and convert it.
    // otherwise, directly parse an ast.
    public makeExpr(input: any|string): expr {
      let inter:any;
      if (typeof input == 'string') {
        inter = this.parseStr(input);
      } else {
        inter = input;
      }

      return DFNetwork.parseExpr(inter);
    }

    // helpers for op parsing
    private static parseBinop(op: string): Eddiflow.bop {
      return match(op,
        (l, r) => l == r,
        [['+', bop.Pls], ['-', bop.Min], ['*', bop.Tim], ['/', bop.Div]],
        new BadExprFormat("expected a binop and found: " + op)
      );
    }
    private static parseUop(op: string): Eddiflow.uop {
      return match(op,
        (l, r) => l == r,
        [['-', uop.Neg]],
        new BadExprFormat("expected a uop and found: " + op)
      );
    }

    // helper to parse strings into structured JSON objects
    private parseStr(s: String): any {
      return this.parser.parse(s);
    }

    // helper to parse exprs from (structured) JSON objects
    private static parseExpr(ast: any): Eddiflow.expr {
      if (!_.has(ast, 'tag') || !_.has(ast, 'body')) {
        throw new BadExprFormat("input object does not have a tag/body: " + ast.toString());
      } else {
        let body = ast.body;
        let ret: expr;
        // TODO: convert to use match
        switch(ast.tag) {
          case 'binop':
            console.log("parsing as bop: ");
            console.log(ast);
            // body looks like: {op: string, lhs: expr, rhs: expr}
            if (!_.has(body, 'lhs') || !_.has(body, 'rhs') || !_.has(body, 'op'))
              throw new BadExprFormat("malformed body tag: " + ast.toString())
            let binop = this.parseBinop(body.op)
            let lhs = this.parseExpr(body.lhs);
            let rhs = this.parseExpr(body.rhs);
            ret = new BinOp(binop, lhs, rhs);
            break;
          case 'unop':
            // body looks like: {op: string, inner: expr}
            if (!_.has(body, 'inner') || !_.has(body, 'op'))
              throw new BadExprFormat("malformed body tag: " + ast.toString())
            let unop = this.parseUop(body.op);
            let inner = this.parseExpr(body.inner);
            ret = new UnOp(unop, inner);
            break;
          case 'app':
            ret = new FunApp(); // TODO
            break;
          case 'number':
            // body is a number
            let result = parseFloat(ast.body);
            // isNan checks if the conversion succeeded, while the funky regex
            // makes sure body isn't all whitespace
            if (/^\s*$/.test(ast.body) || isNaN(result))
              throw new BadExprFormat("expected a numeric body: " + ast.toString());

            ret = result;
            break;
          case 'var':
            // body is a string (variable reference)
            if (typeof(body) != 'string')
              throw new BadExprFormat("expected a string body: " + ast.toString());
            ret = new Var(body);
            break;
          default:
            throw new BadExprFormat("input object tag is malformed: " + ast.toString());
        }

        return ret;

      }

    }

    // Public API: intended usage is
    // <initialize>
    // ... a bunch of addDecl calls ...
    // run:
    // ... getValue calls ...
    // ... a bunch of suggestValue calls, no getValue calls...
    // resolve() -> goto run


    // getter for a value.
    public getValue(name: string): number { return this.cachedVals[name]; }


    // add a dataflow declaration to the network
    public addDecl(name: string, expression:string, initVal: number = 0): void {
      let body = this.makeExpr(expression);
      this.network[name] = body;
      this.cachedVals[name] = initVal; // don't actually evaluate the expr yet
      this.forcedVals[name] = true; // mark the new variable as clean
    }

    // compute forward variable dependencies and transition to suggest/query mode.
    public finalizeDecls(): void {
      // initialize affected lists
      for (var decl in this.network) {
        this.affectedBy[decl] = [];
      }
      // for each variable v1, if another variable v2 mentions v1, v2 is a forward dependency of v1
      for (var v1 in this.network) {
        for (var v2 in this.network) {
          if (
            DFNetwork.collectVars(this.network[v2]).some(
              (v:Var) => v.ref == v1)
            ) {
              this.affectedBy[v1].push(v2);
            }
          }
      }
    }

    // tell the system a variable needs a specific value.
    // mark all the variables forward dependencies as stale.
    public suggestValue(name: string, v: number): void {
      let oldVal = this.cachedVals[name];
      if (oldVal != v) {
        this.cachedVals[name] = v;
        _.each(this.affectedBy[name],
          (stale: string) => {this.forcedVals[stale] = false;}
        );
      }
    }

    // process all suggested value updates and resolve the network
    public resolve(): void {
      // for each stale value...
      let stales: string[] = Object.keys(
        filterMap(this.forcedVals, (k: string, v: boolean) => !v )
      );

      // ...evaluate its expression
      _.each(stales, (vname: string) => this.evalVariable(vname));
    }

    private evalVariable(varName: string): number {

      // if we've already evaluated a variable, return its cached value
      if (this.forcedVals[varName])
        return this.cachedVals[varName];

      // otherwise, evaluate all the dependencies for a variable...
      let varExpr = this.network[varName];
      let deps = DFNetwork.collectVars(varExpr);

      _.each(deps, (varble: Var) => this.evalVariable(varble.ref));

      // ...evaluate the variable and record the result...
      let ret = this.eval(varExpr);
      this.cachedVals[varName] = ret;
      this.forcedVals[varName] = true;

      // ...and evaluate everything that depends on the variable.
      let forwardDeps = this.affectedBy[varName];
      _.each(forwardDeps, (vname:string) => {
        if (!this.forcedVals[vname]) {
          this.evalVariable(vname);
        }}
      );

      return ret;
    }
    // helper function for calculating dependencies: return all the free variables
    // in an expression (i.e., what the expression depends on)
    private static collectVars(e:expr) : Var[] {
      if (e instanceof BinOp) {
        let lvs = DFNetwork.collectVars(e.lhs);
        let rvs = DFNetwork.collectVars(e.rhs);
        return lvs.concat(rvs);
      } else if (e instanceof UnOp) {
        return DFNetwork.collectVars(e.inner);
      } else if (e instanceof FunApp) {
        throw new Unimplemented("FunApp freevars");
      } else if (e instanceof Var) {
        return [e];
      } else if (typeof e === 'number') {
        return [];
      } else {
        throw new Unimplemented("Unimplemented expr: " + e.toString())
      }
    }
    // TODO: convert this into an interative function
    // TODO: lift dependencies into a global
    public eval(e:expr): number {
      let ret: number;
      if (e instanceof BinOp) {
        let lv = this.eval(e.lhs);
        let rv = this.eval(e.rhs);
        ret = match(e.op, (l, r) => l == r,
          [[bop.Pls, lv + rv], [bop.Min, lv - rv],
           [bop.Tim, lv * rv], [bop.Div, lv / rv]]
        );
      } else if (e instanceof UnOp) {
        let inner = this.eval(e.inner);
        ret = match(e.op, (l, r) => l == r,
          [[uop.Neg, -1 * inner]]
        );
      } else if (e instanceof FunApp) {
        // TODO
        throw new Unimplemented("evaluating funapp");
      } else if (typeof e === 'number') {
        ret = e;
      } else if (e instanceof Var) {
        ret = this.evalVariable(e.ref);
      } else {
        throw new Unimplemented("unimplemented expr: " + e.toString())
      }

      return ret;
    }
  }
}
