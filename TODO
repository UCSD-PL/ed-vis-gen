TODO:

    ** canonicalize equations? maybe?
    ** > ARG_0: Set(V_1)
       > ARG_1: Set(-3.0 + 3.0*V_2 + 2.0*V_4 ≡ -1.0 - 4.0*V_1 - V_5 + V_0 + 2.0*V_3 - V_2, -5.0 - 3.0*V_5 - 4.0*V_1 ≡ -5.0 + V_3 + 0.0*V_1)
       (violated fuzz testing)


  ** inlining isn't optimal: with a point on weight + point in spring,
     IY = IY_PY is an equation

  * box width/heights being negative are nonsensical:
    ** solve inversion
    ** add inequalities to enforce orientation

  * box height/width resizing for center points is weird...
  * explore locked edges for locking variables (specifically height/width)
  * or maybe learn from rejects? multi tier accept/reject phases?



  * finish point generation
    ** add triangles
  * finish AST
    ** add plots
    ** add inequalities to expressions

  * make merging links more precise

  * convert current benchmarks (on benchmarking branch) to linear/nonlinear version
  * find more benchmarks
    ** http://www.malinc.se/math/
    ** JSXGraph
    ** my solar system

ranking:
  * interactions tend to be at connection points
  * penalty for shape w/o interactive components
  * filter out "functionally identical" diagrams...
    ** positional equivalence: all points are in same place + have same links



distinguish between recursive updates and nonlinear one-way constraints:
  * recursive update semantics are: take old values of variable references.
  * nonlinear semantics are: ignore cycles (i.e. eval each node exactly once),
                             update a la dataflow graph
  * extend values:
    ** CassValues
    ** DFValues
    ** interface:
      *** getValue
      *** suggestValue
      *** evaluate
    ** type system: DFValues can't appear in cass equations and vice versa
  * runtime semantics:
    ** interactions: suggestValue for x, y values. reevaluate both networks.

  * user input:




  NLP: given some text in a textbook describing a sim,
  spit out a diagram implementing the sim
